import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { generateGeminiImage } from '@/lib/utils/gemini-image'

/**
 * POST /api/ai/generate-image
 * Supports dual model: Gemini (default) and Imagen 4.0 (legacy).
 * Returns the generated image URL after uploading to Supabase Storage.
 */

const BRAND_PREFIX = `For a Mediterranean restaurant bar called GrandCafe Cheers in Mallorca, Spain.
Brand colors: deep burgundy/wine. Style: warm, Mediterranean, premium casual.
`

const BRAND_SUFFIX = `\nDo NOT include any text in the image unless specifically requested.`

async function generateWithImagen(enhancedPrompt: string, aspectRatio: string) {
  const apiKey = process.env.GOOGLE_AI_API_KEY
  if (!apiKey) throw new Error('GOOGLE_AI_API_KEY not configured')

  const response = await fetch(
    `https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-001:predict?key=${apiKey}`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        instances: [{ prompt: enhancedPrompt }],
        parameters: { sampleCount: 1, aspectRatio },
      }),
    }
  )

  if (!response.ok) {
    const errorText = await response.text().catch(() => 'Unknown error')
    throw new Error(`Google Imagen API error: ${response.status} â€” ${errorText}`)
  }

  const data = await response.json()
  const prediction = data.predictions?.[0]
  if (!prediction?.bytesBase64Encoded) {
    throw new Error('No image generated by Imagen')
  }

  return {
    imageBase64: prediction.bytesBase64Encoded,
    mimeType: prediction.mimeType || 'image/png',
  }
}

export async function POST(request: NextRequest) {
  const hasGemini = !!(process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY)
  if (!hasGemini) {
    return NextResponse.json({ error: 'Google AI not configured' }, { status: 501 })
  }

  const supabase = await createClient()
  const { data: { user }, error: authError } = await supabase.auth.getUser()
  if (authError || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  let body: { prompt?: string; purpose?: string; aspect_ratio?: string; model?: 'gemini' | 'imagen' }
  try {
    body = await request.json()
  } catch {
    return NextResponse.json({ error: 'Invalid JSON' }, { status: 400 })
  }

  const { prompt, purpose = 'general', aspect_ratio = '1:1', model = 'gemini' } = body
  if (!prompt || typeof prompt !== 'string') {
    return NextResponse.json({ error: 'prompt field is required' }, { status: 400 })
  }

  const enhancedPrompt = BRAND_PREFIX + prompt + BRAND_SUFFIX

  try {
    let imageBase64: string
    let mimeType: string

    if (model === 'imagen') {
      const result = await generateWithImagen(enhancedPrompt, aspect_ratio)
      imageBase64 = result.imageBase64
      mimeType = result.mimeType
    } else {
      const result = await generateGeminiImage(enhancedPrompt, {
        aspectRatio: aspect_ratio as '1:1' | '16:9' | '9:16' | '4:3' | '3:4',
      })
      imageBase64 = result.imageBase64
      mimeType = result.mimeType
    }

    // Upload to Supabase Storage
    const imageBuffer = Buffer.from(imageBase64, 'base64')
    const ext = mimeType.includes('png') ? 'png' : 'jpg'
    const filename = `ai-images/${user.id}/${Date.now()}-${purpose}.${ext}`

    const { error: uploadError } = await supabase.storage
      .from('ai-generated-images')
      .upload(filename, imageBuffer, {
        contentType: mimeType,
        upsert: false,
      })

    if (uploadError) {
      console.error('Storage upload error:', uploadError.message)
      return NextResponse.json({
        image_base64: imageBase64,
        mime_type: mimeType,
        purpose,
        prompt,
        model,
      })
    }

    const { data: publicUrl } = supabase.storage
      .from('ai-generated-images')
      .getPublicUrl(filename)

    try {
      await supabase.from('ai_generated_images').insert({
        user_id: user.id,
        prompt,
        purpose,
        storage_path: filename,
        public_url: publicUrl.publicUrl,
      })
    } catch {
      // Non-critical
    }

    return NextResponse.json({
      public_url: publicUrl.publicUrl,
      storage_path: filename,
      purpose,
      prompt,
      model,
    })
  } catch (error) {
    console.error('Image generation error:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Image generation failed' },
      { status: 500 }
    )
  }
}
